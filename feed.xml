<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2017-01-31T23:44:37+00:00</updated><id>//</id><entry><title type="html">Сборщик мобильных приложений 1С.</title><link href="/2017/01/02/sborshchik-mob-pril.html" rel="alternate" type="text/html" title="Сборщик мобильных приложений 1С." /><published>2017-01-02T00:00:00+00:00</published><updated>2017-01-02T00:00:00+00:00</updated><id>/2017/01/02/sborshchik-mob-pril</id><content type="html" xml:base="/2017/01/02/sborshchik-mob-pril.html">&lt;!--На видео показано как собирать мобильные приложения для ОС Android с помощью инструмента «Сборщик мобильных приложений» от фирмы 1С.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;СБОРЩИК МОБИЛЬНЫХ ПРИЛОЖЕНИЙ 1С&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
        &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;https://www.youtube.com/embed/M6NG3SFJCHA&quot; allowfullscreen&gt;&lt;/iframe&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;На видео показано как собирать мобильные приложения для ОС Android с помощью инструмента «Сборщик мобильных приложений» от фирмы 1С.&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1cvideo" /><summary type="html"></summary></entry><entry><title type="html">Как выдать 1С замуж за Zato ESB.</title><link href="/2015/05/01/kak-vydat-1s-zamuzh-za-zato-esb.html" rel="alternate" type="text/html" title="Как выдать 1С замуж за Zato ESB." /><published>2015-05-01T00:00:00+00:00</published><updated>2015-05-01T00:00:00+00:00</updated><id>/2015/05/01/kak-vydat-1s-zamuzh-za-zato-esb</id><content type="html" xml:base="/2015/05/01/kak-vydat-1s-zamuzh-za-zato-esb.html">&lt;!--Пример интеграции ZATO ESB и 1С.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Как выдать 1С замуж за Zato ESB&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Организации, в которых мы работаем, очень часто растут. С ростом организации увеличивается и количество людей, которые в ней работают, увеличивается и IT-стек (в котором есть кнопка «Бабло»). Все чаще в отдел разработки попадают задачи по интеграции 1С из другими системами, будь то телефония, мобильные приложения, корпоративные порталы или датчики контроля использования туалетной бумаги. Весь зоопарк должен работать быстро, а администрирование и обслуживание не должно занимать много времени. Я веду тому, что рано или поздно мы придем к ESB. Ранее &lt;a href=&quot;https://plus.google.com/116720578704525529319&quot;&gt;+Валентин Будкин&lt;/a&gt; уже написал замечательную статью о том, что такое Zato, настоятельно рекомендую заинтересованных людей ознакомится. В этой статье, мы с вами попробуем немного попрактиковаться: развернуть ПО с помощью docker’а, создать интерфейс, с помощью которого будем получать данные из 1С, кэшировать данные в Redis, валидировать кэш. Ну и я постараюсь рассказать о тех подводных камнях, на которые наткнулся сам.&lt;/p&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;КАК РАЗВЕРНУТЬ КОНТЕЙНЕР ИЗ ZATO&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Первое что нам необходимо сделать – найти компьютер из Linux (можно использовать виртуальную машину) и установить на нем docker. Детально как провести установку zato из под докера описано на сайте производителя. Я же хочу отметить, что установить под Ubuntu 14.04.02 (Desktop) так и не удалось, пришлось сделать отдельный образ Ubuntu и внести изменения в докер-файл(в самом начале добавлены строчки):&lt;/p&gt;
      &lt;pre&gt;&lt;code&gt;FROM sequenceiq/pam:ubuntu-14.04
RUN ln -s -f /bin/true /usr/bin/chfn&lt;/code&gt;&lt;/pre&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;После внесения изменений в файл, можно свободно запускать наш «image» (выполнение команд из инструкции). После запуска контейнера мы сможем подключиться к нашей шине с помощью браузера.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/pervyy_zapusk.png&quot; class=&quot;img-fluid&quot; alt=&quot;Административная панель Zato&quot;&gt;
        &lt;/div&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ПОДГОТОВКА ВЕБ-СЕРВИСА В 1С&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Пока забудем не на много о Zato. Задавайте создадим интерфейс коммуникации с внешним миром для 1С. Для решения нашей задачи я выбрал механизм веб-сервисов, это быстро, надежно и Zato умеет работать из SOAP. В нашем интерфейсе будет один метод – getPartnerBalance, который возвращает задолженность партнера по его идентификатору.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/xdto.png&quot; class=&quot;img-fluid&quot; alt=&quot;Структура XDTO пакета для работы из Zato ESB&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В объекте PartnerBalanceMetaData будет возвращаться служебная информация (тег Meta свойства Code, ErrorType, ErrorMessage), и данные для работы из внешнего сервиса (тег Data, свойства PartnerID, Balance). Также необходимо не забыть указать уникальное URI пространства имен (в нашем случае http://www.avtomat.biz/partner_balance).&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Теперь перейдем к созданию самого веб-сервиса. У нас будет один метод, который возвращает данные о балансе партнера в валюте управленческого учета. Выглядеть он будет примерно так:&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/veb_servis.png&quot; class=&quot;img-fluid&quot; alt=&quot;Веб-сервис для передачи данных в Zato по протоколу SOAP&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Определим код нашего веб-сервиса.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/700752ae1b8402e34541c56490056769.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Перед выполнением запроса мы должны проверить входной параметр и соответствующим образом сформировать ответ для Zato. Как видно из кода, мы формируем обыкновенный XML-ответ на запрос.&lt;/p&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;КОНФИГУРИРОВАНИЕ ZATO ДЛЯ РАБОТЫ ИЗ 1C&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Для начала нам необходимо задать параметры аутентификации, с помощью которых мы будем подключатся к 1С. Запускаем наш веб-интерфейс, и идем по пункту меню Security – HTTP Basic Auth.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/autentiifkaciya.png&quot; class=&quot;img-fluid&quot; alt=&quot;Создание блока для аутентификации в 1С из Zato&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В открывшемся окне выполняем команду «Create a new HTTP Basic Auth definition», после чего заполняем окно как на рисунку ниже.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/okno_autentifikacii.png&quot; class=&quot;img-fluid&quot; alt=&quot;Окно настройки параметров аутентификации в 1С для Zato&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Username – это наш логин пользователя для подключения к 1С, в которого установлены роли для запуска методов веб-сервиса. Пароль мы должны уже задать из списка полей.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/zamena_parolya.png&quot; class=&quot;img-fluid&quot; alt=&quot;Строка установки пароля для блока аутентификации Zato&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Следующий шаг – нам необходимо задать «SOAP outgoing connection». Это нужно для того, чтобы Zato знал куда ходить за данными, как выполнять подключение к источнику данных, какой логин и пароль вводить и т.д. Переходим по пункту меню Connections – Outgoing – SOAP.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/soap_outgoing.png&quot; class=&quot;img-fluid&quot; alt=&quot;Пункт меню SOAP Outgoing Connection&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;На странице выполним команду «Create a new SOAP outgoing connection» и заполним форму следующим образом.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/outgoing_soap_connection.png&quot; class=&quot;img-fluid&quot; alt=&quot;Окно настройки SOAP Outgoing Connection&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Host – путь к 1С веб-сервису. URL Path – имя веб-сервиса который мы будем использовать. Data format – соответственно формат данных в котором веб-сервис будет отдавать данные в Zato. Security definition – это тот Security Definition который мы создавали в самом начале главы. Serialization type – необходимо установить в Suds. Если все прошло успешно – мы получим утвердительное сообщение.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Следующий шаг – установка сервиса. Сервис – это скрипт на языке Python, который будет заниматься обработкой наших данных и при необходимости сохранять их в Redis. Для создания нового сервиса необходимо выполнить команду Services – List Services.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/service_list.png&quot; class=&quot;img-fluid&quot; alt=&quot;Пункт меню запуска списка сервисов Zato&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Нам необходимо создать скрипт на Python, для последующей загрузки его как сервиса, с помощью кнопки «Upload a service package». Напишем следующий код.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/ae9900069e6a2ca079751ebf080f2c46.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Для начала нам необходимо подключить класс для работы из Zato – Service. Также определим переменную-шаблон REDIS_KEY для формирования ключа для Redis. Класс GetBalance должен быть унаследованным от класса Service. Конструкция self.request.payload содержит в себе параметры POST запроса который будет приходит из вне(интерфейс для него мы добавим несколько позже). С помощью строки self.kvdb.conn.get мы получаем данные из Redis по ключу. Если данные сохранены в базе – смело отдаем их и прекращаем работу. Если же данных нету – мы подключаемся к 1С и вызываем процедуру getPartnerBalance нашего веб-сервиса. В случае возврата кода 200 из 1С, мы записываем данные в Redis и устанавливаем время жизни объекта 30 секунд (для тестового примера) и возвращаем данные клиенту.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Сейчас мы определим интерфейс, который будет отдавать баланс партнера из Zato. Переходим в пункт Connections – Channels – Plain HTTP.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/channels.png&quot; class=&quot;img-fluid&quot; alt=&quot;Вызов и создание канала подключения к веб-сервису 1С&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;На открывшейся странице выполняем команду «Create a new Plain HTTP channel» и заполняем параметры как в примере.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/channels_plaing_http.png&quot; class=&quot;img-fluid&quot; alt=&quot;Форма настройки параметров канала для подключения к веб-сервису 1С&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Name - имя канала. URL path - ссылка по которой можно будем запустить наш сервис. Data format - мы будем получать данные в формате JSON. Service - сервис (наш предыдущий файлик на python) с помощью которого выполняется обработка данных. Security definition - пока не устанавливаем, пример ведь тестовый.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Теперь давайте попробуем протестировать то, что у нас получилось. Я буду использовать Advanced REST Client – дополнение к браузеру Chrom. Запрос будет выглядеть следующим образом.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/post_zapros.png&quot; class=&quot;img-fluid&quot; alt=&quot;POST запрос к сервису ZATO для получения баланса партнера&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;После нажатия кнопки Send, мы получим ответ.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/otvet.png&quot; class=&quot;img-fluid&quot; alt=&quot;Ответ от сервера Zato из балансом партнера&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Если мы захотим проверить, что сохранилось в Redis, то увидим – данные сохранились.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/data_in_redis.png&quot; class=&quot;img-fluid&quot; alt=&quot;Кэш в Redis&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;После истечения 30 секунд (как в примере скрипта было описано), данные кэша сбросятся.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/redis_cache_invalid.png&quot; class=&quot;img-fluid&quot; alt=&quot;Пустой кэш в Redis&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Если мы проанализируем время отклика – данные из кэша получаются примерно в 4 раза быстрее чем из 1С.&lt;/p&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ВАЛИДАЦИЯ КЭША ZATO&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Припустим, что в базе на партнера менеджер провел финансовый документ, но сервис получил данные о балансе партнера на несколько минут ранее. В таком случае нам необходимо обновить кэш уже из 1С, например во время подписки на проведение документа. Давайте сейчас попробуем организовать запись в Zato по событию из 1С.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Для начала – напишем простой сервис, который будет принимать ID партнера, и его баланс, а потом выполнять запись в кэш. Код будет выглядеть следующим образом.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/c17c27d32c94f6cec3ec780007733be5.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Загрузим наш сервис в Zato и перейдем к конфигурации каналов. Создадим как и в прошлом примере простой Plain HTTP Chanel. Примерные настройки будут как на картинке.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/update_balance.png&quot; class=&quot;img-fluid&quot; alt=&quot;Канал для обновления кэша в Zato&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Теперь мы сможем написать 1С код, который обновляет баланс партнера через POST – запрос к шине при необходимости.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/4d0da17c66965a33363495da701ab87b.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Если мы подключим код к выполнению проведения документа, получим следующий результат (проверим кэш еще раз).&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-05-01-kak-vydat-1s-zamuzh-za-zato-esb/data_in_redis_1.png&quot; class=&quot;img-fluid&quot; alt=&quot;Кэш в Redis&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Что же сказать напоследок? Мы совсем недавно начали использовать Zato в своем стэке, но механизм очень удобен и появилось очень много задач по интеграции из 1С. Посмотрим конечно, будет ли все нормально работать, если нагрузка на систему возрастет, но пока что все предельно ясно и понятно.&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1carticle" /><summary type="html"></summary></entry><entry><title type="html">MongoLab REST API из 1С. Первые шаги.</title><link href="/2015/01/30/mongolab-rest-api-iz-1s-pervye-shagi.html" rel="alternate" type="text/html" title="MongoLab REST API из 1С. Первые шаги." /><published>2015-01-30T00:00:00+00:00</published><updated>2015-01-30T00:00:00+00:00</updated><id>/2015/01/30/mongolab-rest-api-iz-1s-pervye-shagi</id><content type="html" xml:base="/2015/01/30/mongolab-rest-api-iz-1s-pervye-shagi.html">&lt;!--В этой статье хочу познакомить читателей из сервисом MongoLab. Там мы можем получить 500 бесплатных мегабайт пространства для тестов, а также удобный REST api, с помощью которого, у нас получиться поковырять данный сервис из 1С..--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;MongoLab REST API из 1С. Первые шаги.&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В мире 1С у нас наверняка никогда не будут использоваться документ-ориентированные базы данных, да еще как Saas. Мы обитаем в реляционной среде, нередко жалуемся на производительность и лишь единицы из нас могут соприкоснуться из задачами высоконагруженных сервисов. NoSQL базы данных сейчас в тренде и очень часто используются в мире наших соседей. Существует даже мнение – если вы не можете объяснить зачем вам нужна реляционная база, тогда используйте NoSQL. Хотя мы и не задаемся таким вопросом вообще, но де-факто у нас нету выбора. 1С печется о нас и частично скрывает проблемы нормализации базы и облегчает доступ к данным. Но все же, думаю, что когда-то у нас станет как у всех, хотя бы будет возможность выбора (недаром в 8.3.7 нам дадут сериализатор JSON).&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В этой статье хочу познакомить читателей из сервисом MongoLab. Там мы можем получить 500 бесплатных мегабайт пространства для тестов, а также удобный REST api, с помощью которого, у нас получиться поковырять данный сервис из 1С.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;После успешной регистрации нам необходимо узнать наш API key, с помощью которого будет проходить авторизация при POST/GET запросах к сервису. Узнать ключ можно в профиле пользователя, выглядит он примерно следующим образом.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-01-30-mongolab-rest-api-iz-1s-pervye-shagi/api_key.png&quot; alt=&quot;API KEY для сервиса MongoLab&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В принципе это все что нам нужно от сервиса. Теперь можно открывать любимый конфигуратор и что-нибудь написать.Для начала, давайте получим список баз, которые нам доступны. Выполним код.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/796043c1e1f5557daaf42dac88f705e4.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В результате к нам придет очень простой ответ.&lt;/p&gt;
      &lt;pre&gt;&lt;code&gt;[ &quot;test&quot; ]&lt;/code&gt;&lt;/pre&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;И действительно у нас доступно только одна база.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-01-30-mongolab-rest-api-iz-1s-pervye-shagi/test_database.png&quot; alt=&quot;Список баз на сервисе MongoLab&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Теперь посмотрим сколько коллекций в нашей базе.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/385cc5254cf388d8bc96699ddd0bcd0b.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Посмотрим на ответ.&lt;/p&gt;
      &lt;pre&gt;&lt;code&gt;[ &quot;system.indexes&quot; , &quot;system.users&quot; , &quot;unicorns&quot; ]&lt;/code&gt;&lt;/pre&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-01-30-mongolab-rest-api-iz-1s-pervye-shagi/collections.jpg&quot; alt=&quot;Список коллекций в базе.&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Получения списка документов в коллекции осуществляется по накатанной схеме (изменяется только URL). Как видите, все очень просто. Давайте теперь усложним задачу и попробуем создать документ в коллекции. Для выполнения задачи на понадобится отправить сервису POST запрос, а в тело запроса добавить «текст запроса» в формате JSON.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/fdb17c6ac0dae71b6e2b471267bc0046.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Давайте посмотрим что получилось.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2015-01-30-mongolab-rest-api-iz-1s-pervye-shagi/document_created.png&quot; alt=&quot;Документ созданный на сервисе MongoLab&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;И действительно, документ создался. Вот так работают простые примеры из справки, вы можете попробовать все самостоятельно. У меня есть большие надежды что такая замечательная база как MongoDB или другое NoSQL решение все же будут использоваться в стеке 1С как говориться «из коробки».&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1carticle" /><summary type="html"></summary></entry><entry><title type="html">Запуск отчета СКД в привилегированном режиме 1C.</title><link href="/2014/12/08/zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c.html" rel="alternate" type="text/html" title="Запуск отчета СКД в привилегированном режиме 1C." /><published>2014-12-08T00:00:00+00:00</published><updated>2014-12-08T00:00:00+00:00</updated><id>/2014/12/08/zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c</id><content type="html" xml:base="/2014/12/08/zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c.html">&lt;!--Иногда возникают ситуации, когда нужно дать пользователю возможность запускать отчет не смотря на права (в привилегированном режиме).В статье мы рассмотрим два возможных запуска отчета в привилегированном режиме.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Запуск отчета СКД в привилегированном режиме 1C.&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Иногда возникают ситуации, когда нужно дать пользователю возможность запускать отчет не смотря на права (в привилегированном режиме). Один из примеров – когда твой Team Lead запретил добавление новых ролей к базе, «потому что итак все глючит», а заказчик (начальник) хочет, чтобы пользователи могли смотреть супер важную аналитику по регистрам из самописных (костылей) подсистем. В статье мы рассмотрим два возможных запуска отчета в привилегированном режиме:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;Из использованием вида набора данных «Объект»;&lt;/li&gt;
        &lt;li&gt;Из подменой текста запроса набора данных «Запрос».&lt;/li&gt;
      &lt;/ul&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Для возможности проверки результатов создадим тестовую конфигурацию, куда добавим два пользователя: администратор и менеджер.  У менеджера будет ограничение по правам – ему будет недоступен для чтения регистр «Продажи». Попробуем построить отчеты по регистру «Продажи» и посмотрим что у нас получится. Выгруженную конфигурацию можно скачать на Bitbucket.&lt;/p&gt;
    &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ОТЧЕТ С НАБОРОМ ДАННЫХ «ОБЪЕКТ»&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Метод очень хорошо описан и в интернете, и в литературе. Суть заключается в переопределении обработчика «При компоновке результата», в котором мы программно формируем таблицу значений, которую потом загружаем в наш отчет. Приведем код обработчика.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/f5d09697f162e2e3d2ef4b0b2a1ee77e.js&quot;&gt;&lt;/script&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;В обработке мы отказываемся от стандартной обработки компоновки отчета и перенаправляем процедуру формирования отчета в общий модуль, в котором установлена галочка «привилегированный». Код в общем модуле стандартный, приведем его.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/63d18db92dd33e991c099dce16afe387.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Сначала мы получаем таблицу значений (ТаблицаПродаж) из колонками (Номенклатура, Количество, Сумма). Потом таблица загружается в внешний набор данных. В результате чего у пользователя «Менеджер» (с ограниченными правами) будет сформирован следующий отчет.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt; 
      &lt;img src=&quot;/images/2014-12-08-zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c/otchetchereznabor.png&quot; class=&quot;img-fluid&quot; alt=&quot;Програмный вывод отчета через внешний набор данных&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ОТЧЕТ ИЗ ПОДМЕНОЙ ТЕКСТА ЗАПРОСА СКД&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Для начала сформируем набор СКД «заглушку», которую будем использовать далее для подмены текста запроса.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-12-08-zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c/skdzaglushka.png&quot; class=&quot;img-fluid&quot; alt=&quot;Заглушка СКД для подмены запроса&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Для того, чтобы облегчить себе последующие мучения – сформируем так же настройки компоновки, менять из процессе вывода результата не будем.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-12-08-zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c/nastroykikomponovki.jpg&quot; class=&quot;img-fluid&quot; alt=&quot;Настройки макета СКД отчета&quot;&gt;
    &lt;/div&gt; 
      &lt;p class=&quot;text-fluid&quot;&gt;Следующий наш шаг – предопределить процедуру обработчика «При компоновке результата», как и предыдущем способе.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/e1962b17c50e5dae7f84d1c6cfdb3169.js&quot;&gt;&lt;/script&gt; 
      &lt;p class=&quot;text-fluid&quot;&gt;Как видно из кода – мы аналогично отказываемся от стандартной обработки процедуры и перенаправляем поток выполнения в общий модуль из галочкой «привилегированный». Давайте посмотрим на процедуру «СформироватьОтчетПодменаЗапросаСКД».&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/25f7deb554b1b7c55d8d879335979531.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Сначала мы получаем текст необходимого запроса (переменная ТекстЗапроса). Далее устанавливаем текст запроса в основной набор компоновки, а потом уже применяем пользовательские настройки, которые установил пользователь и выводим результат. Хочу также обратить внимание на то, что последний параметр КомпоновщикМакета.Выполнить необходимо устанавливать в Ложь, тогда компоновщик макета будет игнорировать доступность полей отчета по правам.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
     &lt;img src=&quot;/images/2014-12-08-zapusk-otcheta-skd-v-privilegirovannom-rezhime-1c/podmenazaprosaskd.png&quot; class=&quot;img-fluid&quot; alt=&quot;Результат вывода отчета подмена запроса СКД&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Итак, почему же я вижу второй вариант предпочтительнее первого. Второй вариант делает выполнение отчета более гибким и оптимальным, поскольку СКД умеет самостоятельно оптимизировать код запроса. В первом варианте мы сначала выполняем построение таблицы, а уже потом загрузку. Если пользователь установит дополнительный отбор – СКД его выполнит уже к сформированной таблице, а во втором варианте отбор отработает непосредственно в основном запросе. В результате отчет будет выполняться быстрее.&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1carticle" /><summary type="html"></summary></entry><entry><title type="html">Автоматическая интеграция внешних обработок в конфигурацию 1C.</title><link href="/2014/11/02/avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c.html" rel="alternate" type="text/html" title="Автоматическая интеграция внешних обработок в конфигурацию 1C." /><published>2014-11-02T00:00:00+00:00</published><updated>2014-11-02T00:00:00+00:00</updated><id>/2014/11/02/avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c</id><content type="html" xml:base="/2014/11/02/avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c.html">&lt;!--Задумка следующая: у нас исходники хранятся на bitbucket, значит нужно интегрировать его из Jenkins, чтобы когда мы делали merge ветки develop в master, CI подхватывал все это добро и самостоятельно подключал к базе..--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Автоматическая интеграция внешних обработок в конфигурацию 1C&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Вот уже некоторое время мы ведем разработку через git-flow. Все очень нравится. Но есть один момент - когда выходит релиз и ветка develop мигрирует в ветку master, очень лень подключать новые внешние обработки к базе вручную. Вот поэтому я решил продолжить занятие сексом из Jenkins и другими штуками для СІ. Проект у нас еще не внедрен, но вот хотелось бы выложить свои мысли в блоге, авось кто прочтет и даст совет.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Итак, что нам нужно:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;Конфигурация на БСП.&lt;/li&gt;
        &lt;li&gt;Jenkins который выведен «наружу».&lt;/li&gt;
        &lt;li&gt;Python.&lt;/li&gt;
        &lt;li&gt;Три или четыре кружки кофе(шутка).&lt;/li&gt;
      &lt;/ul&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Задумка следующая: у нас исходники хранятся на bitbucket, значит нужно интегрировать его из Jenkins, чтобы когда мы делали merge ветки develop в master, CI подхватывал все это добро и самостоятельно подключал к базе.&lt;/p&gt;
    &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ШАГ 1. ОБРАБОТКА-ИНТЕГРАТОР НА 1С.&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Данная обработка вызывается CI в пакетном режиме. Как параметр запуска передается список полных путей к файлам которые нужно подключить к базе. Многие штуки (интеграция из чатом Slack, подключение внешней обработки/отчета) у нас уже интегрированы в конфигурацию. Обработка парсит параметры запуска и подключает файлики к базе. После подключения приходит сообщение в корпоративный чат о результатах. Если обработки еще нет в базе – ее необходимо подключить вручную. Вот небольшие фрагменты кода.&lt;/p&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Код который парсит параметры запуска и помещает файлы во временное хранилище.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/eb096ec6715ee602590dbdac420ef619.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Здесь также происходит заполнение служебных структур и массив (МассивАдресов, МассивОшибок) для последующей обработки данных.&lt;/p&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;А вто код, который подключает обработки к базе с помощтью функционала БСП.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/3b6fbc639ab67f51ff3b04785a35de7c.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;В коде сразу генерируются служебные сообщения, которые потом будут выведены в корпоративный чатик.&lt;/p&gt;
    &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ШАГ 2. СКРИПТ НА PYTHON.&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Идея скрипта состоит в том, чтобы через команду git diff сравнить локальный master и master удаленный, а файлы которые изменились – записать в базу. Скрипт состоит из нескольких логических блоков. Первый блок делает пресловутый git diff и получает список измененных файлов.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/c138e83827f2f0a9c380cb0eb86301a9.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Участок кода который запускает 1С в пакетном режиме и передает на вход обработки из шага №1 список измененных файлов.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/f734b5f140f3e97681ccf7a0ca3d8658.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;В скрипте есть еще некоторые служебные процедуры, но в рамках данной статьи приводить их не будем.&lt;/p&gt;
    &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ШАГ 3. КОНФИГУРИРУЕМ JENKINS.&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Перейдем к самому вкусному - конфигурированию нашего job-а. Для начала укажем репозиторий откуда тянем изменения.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/repozitoriy.png&quot; class=&quot;img-fluid&quot; alt=&quot;Удаленный репозиторий в Jenkins&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Далее необходимо указать что удаленный мастер будет копироваться в локальную ветку localmaster (в конце мы делаем merge).&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/vetka.png&quot; class=&quot;img-fluid&quot; alt=&quot;Настройки клонирования веток в Jenkins&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Следующая настройка – самая важная для интеграции из bitbucket, а именно – генерирование токена аутентификации. Он нам нужен чтобы bitbucket мог запускать jobs на нашем CI удаленно. Токен должен быть сверхсекретным ;)&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/token.png&quot; class=&quot;img-fluid&quot; alt=&quot;Создание Authentication Token в Jenkins&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Ну и следующая настройка – непосредственный вызов скрипта через пункт Execute Windows batch command.&lt;/p&gt;
   &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/vyzov_skripta.png&quot; class=&quot;img-fluid&quot; alt=&quot;Вызов скрипта&quot;&gt;
    &lt;/div&gt; 
    &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ШАГ 4. НАСТРОЙКИ BITBUCKET HOOK.&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Чтобы bitbucket мог дергать наш CI нам нужно настроить так называемый Jenkins Hook. Перейдем в настройки репозитория в раздел Integrations подраздел Hooks. В меню Select a hook выберем пункт Jenkins.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/hook.png&quot; class=&quot;img-fluid&quot; alt=&quot;Настройка Jenkins hook&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Нам нужно заполнить всего три поля. Endpoint – сюда пишем адрес нашего CI сервера в формате http|s://username:password@domain:port/path, где username - User ID, а password - API Token. Посмотреть данные настройки можно если пойти в меню People, далее выбрать пользователя и открыть секцию API Token из настроек.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/apitoken.png&quot; class=&quot;img-fluid&quot; alt=&quot;Просмотр Api Token&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;Project name – имя проекта, который мы выбрали в Jenkins. Здесь нужно заметить, что имена job-ам нужно стараться давать без пробелов, а если у вас установлен плагин для каталогов в списке проектов, путь к проекту будет выглядеть так Auto_deploy/job/Auto_deploy_test, где Auto_deploy – имя каталога, Auto_deploy_test – имя проекта.&lt;/p&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Поле Token содержит наш токен аутентификации, который мы сгенерировали на шаге №3.&lt;/p&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Вот собственно и все. Результаты работы будут примерно таковы&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-11-02-avtomaticheskaya-integraciya-vneshnih-obrabotok-v-konfiguraciyu-1c/rezultaty.png&quot; class=&quot;img-fluid&quot; alt=&quot;Результаты работы&quot;&gt;
    &lt;/div&gt; 
    &lt;p class=&quot;text-fluid&quot;&gt;В подхода есть некоторые недостатки, а именно, Jenkins при каждом комите будет проверять наши ветки на изменения, что наверное затратно по производительности. С другой стороны процесс переноса наработок в продакшен хоть немного, но стает автоматическим.&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1carticle" /><summary type="html"></summary></entry><entry><title type="html">Автоматизируем процедуру обновления xddTestRunner с помощью Jenkins.</title><link href="/2014/09/28/avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins.html" rel="alternate" type="text/html" title="Автоматизируем процедуру обновления xddTestRunner с помощью Jenkins." /><published>2014-09-28T00:00:00+00:00</published><updated>2014-09-28T00:00:00+00:00</updated><id>/2014/09/28/avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins</id><content type="html" xml:base="/2014/09/28/avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins.html">&lt;!--Вот я и решил немного автоматизировать процесс обновления обработки xddTestRunner.epf.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Автоматизируем процедуру обновления xddTestRunner с помощью Jenkins&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Вот уже на протяжении нескольких недель наша команда пытается внедрить CI в процесс разработки программного обеспечения. Все пишут тесты, матерятся, снова пишут, ну одним словом все идет своим чередом, как у всех.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Для тестирования мы используем замечательный open source инструмент xUnitFor1C. Он позволяет запускать тесты не только интерактивно, но и в пакетном режиме, заблаговременно сохраняя результаты в xml – файл который понимает плагин JUnit для Jekins. Все бы ничего, но разработка в проекте идет настолько активно, что редко успеваешь вовремя обновляться, то ли из-за большой лени, то ли из-за большого потока текучки. Вот я и решил немного автоматизировать процесс обновления обработки xddTestRunner.epf. Ну а чего, Jekins умный, пускай сам о себе позаботится.&lt;/p&gt;
      &lt;p class&quot;text-fluid&quot;&gt;Для успешного выполнения задания нам понадобятся следующие инструменты: непосредственно сам Jekins (предварительно сконфигурированный для работы с git), и установленный Python версии 3.4 и выше. Наш план таков:&lt;/p&gt;
     &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-09-28-avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins/shemaraboty.png&quot; class=&quot;img-fluid&quot; alt=&quot;Схема автооновления&quot;&gt;
     &lt;/div&gt;
     &lt;p class=&quot;text-fluid&quot;&gt;Jenkins получает новые файлы из репозитория. После их получения специальный скрипт на python сравнивает уже существующий файл и новый. Если есть различия – свежая версия xddTestRunner подменяет старую, а пользователям в slack-чат отправляется уведомление об обновлении файла из ссылкой на новую версию.&lt;/p&gt;
     &lt;p class=&quot;text-fluid&quot;&gt;Давайте посмотрим на настройки Jenkins. Здесь ничего особенного. В разделе Source Code Managment установлена ссылка на репозиторий и ветка, которую будем загружать.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-09-28-avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins/nastroykajenkins1.jpg&quot; class=&quot;img-fluid&quot; alt=&quot;Настройки раздела «Source Code Managment»&quot;&gt;
     &lt;/div&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Следующий раздел, который нам необходимо заполнить – Build. В нем мы должны заполнить секцию Execute Windows batch command, где будем запускать наш скрип сравнения файлов.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-09-28-avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins/nastroykijenkins2.png&quot; class=&quot;img-fluid&quot; alt=&quot;Настройка раздела «Build»&quot;&gt;
     &lt;/div&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Настройка Jenkins окончена. Давайте рассмотрим наш скрипт, который будет сравнивать, подменять файлы и отправлять сообщения в slack.&lt;/p&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Первая важная функция – отправка оповещения в чат. Взял я ее отсюда. Приведем листинг кода.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/5b1fd15aad2414331eeac5df9de7f075.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;text-fluid&quot;&gt;Процедура сравнения файлов и копирования файлов – совсем простая задача.&lt;/p&gt;
    &lt;script src=&quot;https://gist.github.com/0xporky/c3889ee5414b488d37c38e8d4b227983.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;test-fluid&quot;&gt;В результате мы получаем вот такое симпатичное сообщение.&lt;/p&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;img src=&quot;/images/2014-09-28-avtomatiziruem-proceduru-obnovleniya-xddtestrunner-s-pomoshchyu-jenkins/soobshchenieslack.png&quot; class=&quot;img-fluid&quot; alt=&quot;Сообщение в slack-чате&quot;&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1carticle" /><summary type="html"></summary></entry><entry><title type="html">Конфигурация «Мобильные отчеты» для УТ 3.</title><link href="/2014/05/10/konfiguraciya-mobilnye-otchety-dlya-ut-3.html" rel="alternate" type="text/html" title="Конфигурация «Мобильные отчеты» для УТ 3." /><published>2014-05-10T00:00:00+00:00</published><updated>2014-05-10T00:00:00+00:00</updated><id>/2014/05/10/konfiguraciya-mobilnye-otchety-dlya-ut-3</id><content type="html" xml:base="/2014/05/10/konfiguraciya-mobilnye-otchety-dlya-ut-3.html">&lt;!--В одной из прошлых статей мы с Вами уже обсуждали пример интеграции мобильной платформы из одной типовой конфигураций. В этой статье мы продвинемся в вопросе построения отчетности на мобильной платформе в связке с «Управлением торговлей 3».--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Конфигурация «Мобильные отчеты» для УТ 3&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В одной из прошлых статей мы с Вами уже обсуждали пример интеграции мобильной платформы из одной типовой конфигураций. В этой статье мы продвинемся в вопросе построения отчетности на мобильной платформе в связке с «Управлением торговлей 3».&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Наша задача - дать возможность пользователю настроить вариант отчета в основной базе, а потом формировать отчет в мобильном приложении, предварительно выбирая необходимый вариант.&lt;/p&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;КОНТРАКТЫ ПЕРЕДАЧИ ДАННЫХ&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Давайте для начала подумаем о контрактах, с помощью которых наши базы будут осуществлять обмен. Во-первых, нам необходимо синхронизировать справочник «Варианты отчетов». В этом справочнике сохраняются все варианты отчетов пользователей. Структура метаданных выглядит следующим образом.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/metadannyevariatyotchetov.png&quot; class=&quot;img-fluid&quot; alt=&quot;Структура метаданных справочников и документов&quot;&gt;
      &lt;/div&gt; 
      &lt;p class=&quot;text-fluid&quot;&gt;В справочнике сохраняется очень много информации о нашем варианте отчета: ключ объекта (наименование отчета для которого сохранили вариант), администратор (пользователь, который сохранил вариант), хранилище значений (собственно настройки системы компоновки данных) и т.д. Весь этот громадный набор данных нет смысла передавать на мобильную базу, все равно наш отчет будет формироваться на сервере, а клиент будет получать только сжатый результат (в виде упакованного табличного документа). Утвердил следующую схему обмена: сервер будет отбирать с помощью планов обмена ссылки для передачи на мобильную платформу, сериализовать их в XML файл, с помощью объекта ПреобразованиеXSL удалять лишние атрибуты реквизитов и передавать через веб-сервис клиенту.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/shemaobmenavariantyotchetov.png&quot; class=&quot;img-fluid&quot; alt=&quot;Протокол обмена между УТ 3 и мобильной конфигурацией&quot;&gt;
      &lt;/div&gt; 
      &lt;p class=&quot;text-fluid&quot;&gt;Для непосредственного вывода отчета на телефон буде использоваться схема намного проще, ведь нам нужно только передать сформированный на сервере табличный документ на клиент.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/shemaobmenaotchetom.png&quot; class=&quot;img-fluid&quot; alt=&quot;Протокол передачи табличного документа на мобильное приложение&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;РЕАЛИЗАЦИЯ ВЕБ-СЕРВИСА&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Перейдем к реализации наших схем. Так как нам необходимо в базе УТ добавить новый план обмена и веб-сервис нам необходимо будет снять конфигурацию с поддержки. Снимать будем только корень конфигурации, на процедуру обновления наши изменения не повлияют.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/poddrezhkakonfiguraciiut.png&quot; class=&quot;img-fluid&quot; alt=&quot;Снятие с поддержки конфигурации поставщика УТ 3&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Создадим новый план обмена с наименованием «ОбменОтчеты» и установим авторегистрацию для справочника «ВариантыОтчетов».&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/obmenotchety.png&quot; class=&quot;img-fluid&quot; alt=&quot;Создание нового плана обмена&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;На следующем этапе нам придется создать и опубликовать веб-сервис, с помощью которого будем производить обмен между сервером и клиентом. Назовем веб-сервис «ExchangeReports», также необходимо создать следующие методы:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;«SyncReportTypes» - синхронизирует справочники «Варианты отчетов» между сервером и клиентом.&lt;/li&gt;
        &lt;li&gt;«GetReport» - отправляет сформированный отчет на клиент в виде табличного документа.&lt;/li&gt;
      &lt;/ul&gt; 
      &lt;p class=&quot;text-fluid&quot;&gt;В результате у нас получилась следующая структура метаданных.&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/strukturametadannyhvebservisa.png&quot; class=&quot;img-fluid&quot; alt=&quot;Структура метаданных веб-сервиса&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Итак процедура «SyncReportTypes» в качестве параметра получает узел обмена, с которому необходимо отдать данные. Выглядит это примерно следующим образом.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/5cdff295c26347b0762d4cb0cfdb7fbc.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Следует обратить внимание на функцию СформироватьОтветКлиенту. Сначала сервер должен зарегистрировать изменения которые уже были записаны клиентом (блок ЧтениеХМЛ), а далее выбрать те изменения которые еще не передавались на клиент (блок ЗаписьXML). Также следует обратить внимание на объект ПреобразованиеXSL. С его помощью из сообщения обмена удаляются лишние атрибуты арквизитов справочника «Варианты отчета» которых нету в мобыльном клиенте.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Функция «GetReport» возвращает сформированный отчет на клиент, как параметр ей передается вариант отчета (который мы выбрали на клиенте). Здесь все просто, с помощью ключа варианта отчета ищем необходимые настройки, по имени объекта ищем нужный отчет в базе и программно формируем отчет в СКД. Результат сжимаем и отправляем на клиент.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/ae44778fa257ab21b757aabacb0c6390.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;На клиенте нам нужно создать справочник «ВариантыОтчетов». Здесь нам нужно сохранять только ключ варианта (чтобы искать нужный нам вариант отчета на сервере), а так же описание варианта (чтобы пользователь мог ориентироваться в вариантах отчета).&lt;/p&gt;
      &lt;div class=&quot;text-center&quot;&gt;
        &lt;img src=&quot;/images/2014-05-10-konfiguraciya-mobilnye-otchety-dlya-ut-3/variantyotchetovklient.png&quot; class=&quot;img-fluid&quot; alt=&quot;Справочник 'Варианты отчетов'&quot;&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Синхронизация осуществляется через динамическую WS-ссылку.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/fe8fc3b2d13a74bb1d1e9b378963554c.js&quot;&gt;&lt;/script&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;А сам отчет получаем следующим методом.&lt;/p&gt;
      &lt;script src=&quot;https://gist.github.com/0xporky/ba3bd66dff27019c337282b6da881aaa.js&quot;&gt;&lt;/script&gt;
      &lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot;&gt;&lt;p class=&quot;text-uppercase&quot;&gt;&lt;h3&gt;ИТОГИ&lt;/h3&gt;&lt;/p&gt;&lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Вот так просто мы смогли реализовать простый вывод вариантов отчетов в мобильном приложении из основной конфигурации. Конечно весь код в статье я не приводил, поскольку я думаю что не стоит описывать рисование кнопок. Пример работы приложения можно посмотреть на видео.&lt;/p&gt;
      &lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
        &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;https://www.youtube.com/embed/Vtz6-Jc198Q&quot; allowfullscreen&gt;&lt;/iframe&gt;
      &lt;/div&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Недостатком такого способа вывода отчетов в мобильное приложение - необходимость постоянного подключения к интернету, но он сейчас повсюду :)&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1carticle" /><summary type="html"></summary></entry><entry><title type="html">Работа с файлами в УТ 3.</title><link href="/2014/05/02/rabota-s-faylami-v-ut-3.html" rel="alternate" type="text/html" title="Работа с файлами в УТ 3." /><published>2014-05-02T00:00:00+00:00</published><updated>2014-05-02T00:00:00+00:00</updated><id>/2014/05/02/rabota-s-faylami-v-ut-3</id><content type="html" xml:base="/2014/05/02/rabota-s-faylami-v-ut-3.html">&lt;!--В нашем видео мы коснулись одной из причин стремительного роста базы - хранения дополнительных файлов, например изображений номенклатуры, непосредственно в базе.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Работа с файлами в УТ 3.&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
        &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;https://www.youtube.com/embed/MImd-Psf7as&quot; allowfullscreen&gt;&lt;/iframe&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Очень часто владельцы файловый баз 1С задаются вопросом производительности работы программы. Одной из причиной низкой скорости работы может быть превышение лимита размера файловой базы, поскольку при превышении объема в 4Gb компания 1С натоятельно рекомендует переходить из файлового режима работы в клиент-серверний (даже был выпущен мини сервер 1С на 5 пользовательских лицензий).&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В нашем видео мы коснулись одной из причин стремительного роста базы - хранения дополнительных файлов, например изображений номенклатуры, непосредственно в базе. Мы настоятельно рекомендуем владельцам файловых баз хранить изображения в томах на диске, особенно если у Вас работает обмен между 1С и интернет магазином, иначе с ростом количества товарных позиций будет стремительно расти и база, и как результат будет снижаться производительность работы системы.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1cvideo" /><summary type="html"></summary></entry><entry><title type="html">Внешние обработки и печатные формы в УТ 3.</title><link href="/2014/02/02/vneshnie-obrabotki-i-pechatnye-formy-v-ut-3.html" rel="alternate" type="text/html" title="Внешние обработки и печатные формы в УТ 3." /><published>2014-02-02T00:00:00+00:00</published><updated>2014-02-02T00:00:00+00:00</updated><id>/2014/02/02/vneshnie-obrabotki-i-pechatnye-formy-v-ut-3</id><content type="html" xml:base="/2014/02/02/vneshnie-obrabotki-i-pechatnye-formy-v-ut-3.html">&lt;!--Представляем Вашему вниманию видео, где показаны различные способы подключения внешних печатных форм, обработок и отчетов в конфигурацию Управление торговлей 3 для Украины.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Внешние обработки и печатные формы в УТ 3&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
        &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;https://www.youtube.com/embed/tpeHhDPvAWI&quot; allowfullscreen&gt;&lt;/iframe&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Представляем Вашему вниманию видео, где показаны различные способы подключения внешних печатных форм, обработок и отчетов в конфигурацию Управление торговлей 3 для Украины. Рассмотрены следующие способы подключения:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;дополнительная обработка;&lt;/li&gt;
        &lt;li&gt;внешняя печатная форма;&lt;/li&gt;
        &lt;li&gt;регламентное задание;&lt;/li&gt;
        &lt;li&gt;внешний отчет;&lt;/li&gt;
        &lt;li&gt;заполнение объектов;&lt;/li&gt;
        &lt;li&gt;создание связанных объектов.&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;&lt;a href=&quot;https://github.com/0xporky/vneshnie-obrabotki-i-pechatnye-formy-v-ut-3/blob/master/code.bsl&quot;&gt;Предлагаемый код модуля обработки.&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1cvideo" /><summary type="html"></summary></entry><entry><title type="html">Дополнительные реквизиты и сведения в УТ 3.0.</title><link href="/2013/11/16/dopolnitelnye-rekvizity-i-svedeniya-v-ut-30.html" rel="alternate" type="text/html" title="Дополнительные реквизиты и сведения в УТ 3.0." /><published>2013-11-16T00:00:00+00:00</published><updated>2013-11-16T00:00:00+00:00</updated><id>/2013/11/16/dopolnitelnye-rekvizity-i-svedeniya-v-ut-30</id><content type="html" xml:base="/2013/11/16/dopolnitelnye-rekvizity-i-svedeniya-v-ut-30.html">&lt;!--В видео мы рассмотрели, как добавить дополнительный реквизит к справочнику, как определить тип дополнительного реквизита и как вывести реквизит в один из вариантов отчета.--&gt;
&lt;!--more--&gt;
&lt;div class=&quot;container&quot;&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;h2&gt;&lt;p class=&quot;text-center text-uppercase&quot;&gt;Дополнительные реквизиты и сведения в УТ 3.0&lt;/p&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
        &lt;iframe class=&quot;embed-responsive-item&quot; src=&quot;https://www.youtube.com/embed/frQev0LTH5A&quot; allowfullscreen&gt;&lt;/iframe&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-10&quot;&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;Механизм дополнительных реквизитов и сведений в конфигурации «Управление торговлей для Украины, редакция 3» является универсальным механизмом, который позволяет в пользовательском режиме, без снятия с поддержки конфигурации, добавлять дополнительные (пользовательские) поля (реквизиты) к таким объектам информационной базы как справочники и документы. Благодаря универсальности механизма пользовательские реквизиты можно выводить в стандартных и внешних отчетах, а также использовать при программировании дополнительного функционала.&lt;/p&gt;
      &lt;p class=&quot;text-fluid&quot;&gt;В видео мы рассмотрели, как добавить дополнительный реквизит к справочнику, как определить тип дополнительного реквизита и как вывести реквизит в один из вариантов отчета. Также была продемонстрировано, чем отличается дополнительный реквизит от дополнительного сведения.&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;col-sm-1&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

&lt;/div&gt;</content><category term="1cvideo" /><summary type="html"></summary></entry></feed>
